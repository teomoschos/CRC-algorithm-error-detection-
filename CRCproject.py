#Ονομα:Μοσχος θεοδωρος
#ΑΕΜ:2980

import random
#Αρχικα ζηταμε να μας δωθει για ποσες φορες θα πραγματοποιηθει ο αλγοριθμος ,δηλαδη ποσες φορες θα παραχθει κωδικας crc
# ωστε να εκτιμηθουν τα αντιστοιχα ποσοστα που ζητουνται
data =  int(input("Give the numbers of packages:"))
#καθε μετρητης αντιπροσποπευει την πιθανοτητα καθε ποσοστου
counter1=0#μετρητης για ποσοστο μυνηματων που φθανουν με σφαλμα στον αποδεκτη
counter2=0#μετρητης για ποσοστο μυνηματνω που ανιχνευονται απο το crc
counter3=0#μετρητης για ποσοστο μυνηματων που φθανουν με σφαλμα και δεν εντοπιζονται απο το crc


#ζητηειται ο αριθμος P ,βαση του οποιου θα γινει η διαιρεση
string=input("Give the number for the procces to ocurre:  ")


#Στην παρακατω διαδικασια ελεγχεται εαν ο αριθμος που δινεται απο τον χρηστη ειναι εγκυρος ,βαση
#των κανονων του κωδικα crc
correctdigit=True
for i in str(string):
         if (i=='1' or i=='0'):
              correctdifit = True
         else:
           correctdigit = False
           break

while ( not(string.isdigit()) or string[0]=='0' or string[len(string)-1]=='0' or correctdigit==False ):
    string= input("Give the correct number:  ")
    for i in str(string):
        if (i=='1' or i=='0'):
            correctdigit= True
        else:
            correctdigit = False
            break

#Δημιουργουμαι τον πινακα Ρ στον οποιο θα αποθηκευθει ο αριθμος P
P=[]
for i in range(len(string)):
    P.append(int(string[i]))

#Δημιουργειται ο πινακας Digits ,στον οποιο θα αποθηκευονται τυχαιοι αριθμοι μηκουν 10 (k=10),που θα αποτελουνται
#απο τα ψηφια 0 και 1
lenght = len(P)
#Εδω ξεκινα η επαναληπτικη διαδικασια η οποια θα πραγματοποιηθει αναλογα με το ποσο που θα επιλεξει και θα δωσει
#ο χρηστης αρχικα
for i in range(data):
    Digits=[]
    for j in range (10):
        n=random.randrange(0,2)
        Digits.append(n)

#Πραγματοποιειται η διαδικασια προσθεσης των μηδενικων στο τελος που μηνυματος που εχουμε στειλει
#και επειτα πραγματοποιειται η δημιουργια του κωδικα crc ,μεσω της διαδοχικης διαιρεσης ,κανωντας ουσιαστικα
#την διαδικασια της πυλης XOR
    for j in range(lenght-1):
        Digits.append(0)

    lenght_m=len(Digits)
    t=[]
    for j in range(lenght_m):
        t.append(Digits[j])

    j=0
    while j <lenght_m-lenght+1:
        if(t[j]==1):
            for k in range(lenght):
                if(t[j+k]==P[k]):
                    t[j+k]=0
                else:
                    t[j+k]=1
        if(t[j]==0):
            j=j+1

    F=[]
    j=lenght_m-lenght +1
    for k in range(lenght-1):
        F.append(t[j+k])

    for k in range(len(F)):
        Digits[j+k]=F[k]


#Δημιουργουμαι εναν νεο πινακα,τον πινακα m ο οποιος παιζει τον ρολο του καναλιου ,
# στον οποιο αντιγραφουμε τα στοιχεια του πινακα Digits,δηλαδη
#το τυχαιο μυνημα με τα ψηφια που δημιουργειται  αρχικα και επειτα τον κωδικα crc και επειτα
#αλλαζουμε τις τιμες του ,δηλαδη ουσιαστικα αλλοιωνουμε τα bit του ,βαση του δωσμενου καναλιου(Ε=10^-3)
    m=[]

    for j in range(lenght_m):
        m.append(Digits[j])
        n = random.randrange(0, 1000)
        if(n==50):
            if(m[j]==1):
                m[j]=0
            else:
                m[j]=1

#Εδω αρχιζουμε να ελεγχουμε τις περιπτωσεις για το καθε ποσοστο.Εαν υπαρξει διαφορα μεταξυ του νεου πινακα και του
#αρχικου,τοτε ο πρωτος μετρητης ,δηλαδη αυτος που ελεγχει εαν υπαρχει μυνημα που φθανει με σφαλμα στον αποδεκτη,
#αυξανεται κατα 1 ,και αυτο συμβαινει για καθε φορα που ειμασυε σε αυτη την περιπτωση
    detectionerror= False
    for j in range(lenght_m):
        if(m[j]!=Digits[j] ):
            counter1=counter1+1
            detectionerror= True
            break

    j = 0
    while j < lenght_m - lenght + 1:
        if (m[j] == 1):
            for k in range(lenght):
                if (m[j + k] == P[k]):
                    m[j + k] = 0
                else:
                    m[j + k] = 1
        if (m[j] == 0):
            j = j + 1


#Εδω ελεγχεται η δευτερη περιπτωση ,δηλαδη η περιπτωση οπου το μυνημα που περναει εχει λαθος
#το οποιο εντοπιζεται απο το crc ,εαν συμβει αυτο ο δευτερος μετρητης αυξανεται κατα 1 κι αυτο επαναλαμβανεται
#για καθε τετοια περιπτωση
    found=False
    for j in range(lenght_m):
        if(m[j]==1 ):
            counter2=counter2+1
            found=True
            break

#Τελος ,ελεχχεται τριτη και τελευταια περιπτωση ,δηλαδη το μυνημα που μεταδοθηκε
#να περιεχει σφαλμα και και να μην εχει ανιχνευθει απο το crc,σε αυτη την περιπτωση
#ο τριτος μετρητης που εχουμε αυξανεται κατα 1 και αυτο συμβαινει για καθε φορα που θα
#ειμαστε σε αυτη την περιπτωση.Βεβαια ,αυτη η περιπτωση θα ειναι μηδενικη ,διοτι δεν υπαρχει πιθανοτητα
#να να μην εντοπισθει το λαθος απο τις προηγουμνες περιπτωσεις που αναφεραμε
    if(found==False and detectionerror==True):
        counter3=counter3+1


#Δημιουργουμαι βαση των μετρητων τα ποσοστα ,για την καθε μια απο τις περιπτωσεις
rate1=(counter1/data)*100
rate2=(counter2/data)*100
rate3=(counter3/data)*100


#Εμφανιζουμε τα αντιστοιχα ποσοστα
print("first rate: ","%.5f" % rate1,"%")
print("second rate: ","%.5f" % rate2,"%")
print("third rate: ","%.5f" % rate3,"%")
